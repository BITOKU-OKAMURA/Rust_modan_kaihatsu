# Rust_modan_kaihatsu
PHPのバックエンドフレームワークをRustに移植するプロジェクトです。学習用

# １．概要
PHPで作成したバックエンドフレームワーク (@BITOKU-OKAMURA/php5-planet) をRustに移植する  
作業をRustの学習を兼ねて実施しております。幸い私はswiftを使えるのでRustの学習の敷居は  
それほど高くなく、開発環境さえ用意出来ればすんなりと学習出来ると思います。
ベースとなるWEBフレームワークはactix_webとなります。


# ２．基本構想
ユースケース別にファイルを分けたいので controller というフォルダを作成し  
main関数からmodで呼び出すようにしました。それ以外の外部入出力モジュールは  
resorce_module というフォルダを作成して同様にmodで呼び出すようにしております。  


//--------------------------------------------------------------------------
// ResponseError のラッパー宣言。独自のエラー処理に使用
//--------------------------------------------------------------------------
#[derive(Error, Debug)]
enum MyError {}
impl ResponseError for MyError {}
*/
use actix_web::{web, App,  HttpServer};
use actix_web::middleware::Logger;

//--------------------------------------------------------------------------
// 外部モジュールの読み込み ※クレートにする必要が薄いのでソースで管理
//--------------------------------------------------------------------------
mod resorce_module;//ログとかDBとかのモジュール
mod controller;//コントローラ

# ３．ルーティング
interfaceを使わないでネスト連結？よくわかりませんが、そういうのを使って  
分岐しています。 else ifで連結するようなイメージで私はあまり好みません。  
ルート分岐後の処理のハンドリングは分岐先で完結する感じで  
main関数の制御でスレッド化させてmain関数でひたすらリクエストを待ち受けている状態となっています。  


async fn main() -> std::io::Result<()> {
    resorce_module::logs::log4rs_init("actix_web=info","/tmp/foo.log");
    HttpServer::new(move || App::new().wrap(Logger::default())
        .route("/", web::get().to(controller::index::execute))
        //.route("/req_test/{_user_id}", web::get().to(controller::req_test::execute))
        .route("/req_test/{_user_id}", web::post().to(controller::req_test::execute))
        .route("/input_param/", web::post().to(controller::input_param::execute))
    )
        .bind("0.0.0.0:8080")?
        .run()
        .await?;
    Ok(())
}

# ４．入力チェック
①入力されたフォームハンドラを厳格にチェックするのが私の流儀です。  
これはY社に参画していた時に入力されたフォームハンドラをセキュリティチェックの仕様を  
「結合テスト開始後」に後出しで提示され、文句を言ったら「提示が無くても常識」だと  
跳ねられた経緯があるからです。PHP版もそうですが、アクセス元は全部ハッカーで、  
彼らは個人情報やサーバの操作権を簒奪する目的でアクセスするのを仮定して作っています。  

②Rustにはクラスが無いのでトレイトを作って入力チェックを展開して管理します。
トレイトのメンバをその外部から参照するにはpublicにしないと出来ません。
トレイト自身とそのメンバの権限が分かれており、メンバ毎に独立して管理する事となります。

impl InputParametars {
    //---------------------------------------------------------------------------------
    // トレイト内関数:set_input_parametars
    // ***** 構造体InputParametars として値を代入する。引数項目以外は演算して代入を実施 ******
    // * 目的:フォームハンドラーの値を精査し、サーバエラーで無くヴァリテーションバックとして返却*
    // * 境界値チェックや不正アクセスの精査を体系的に実施                                                          *
    // ***************************************************************************
    //--------------------------------------------------------------------------------- 
    pub fn set_input_parametars (
        //----- 引数一覧 -----//
        args: String,                  //ハンドラ文字列(ハンドラ名はハッシュの添え字で判別)
        string_type_in: bool,   //文字列で扱うなら true それ以外なら false
        mut message_in: String,    //ヴァリテーションバック時のメッセージ文字列
        min_in:i32,                  //最小値、文字列の場合は文字列数 -1で無視 ※ディフォルト不可
        max_in:i32,                 //最大値、文字列の場合は文字列数 -1で無視 ※ディフォルト不可
        check_regix_in:String,
        //----- 戻り値 -----//
        ) -> InputParametars { //戻り値の型は構造体InputParametars
}

③入力されたフォームは型固定されております。一見モダンでセキュアに見えますが、型を破った入力がされた場合  
actix_webでリクエストエラーとしてハンドリングされてしまいます。  
これは都合が悪いのでフォームハンドラに何を入力しても文字列として、入力チェックで型を管理します。  

        //--------------------------------------------------------------------------     
        //  整数の処理 文字列を整数に変換
        //-------------------------------------------------------------------------- 
        let ret_intvalue :i32 =
        if regix_jissuu.is_match(&args) == false {
            0
        } else {
            let _data=regix_seisuu.captures(&args).unwrap().at(0).unwrap();
            let sandata: i32 = _data.parse().expect("変換できない文字列でした");
            sandata
         };

        //--------------------------------------------------------------------------     
        //  文字列長 ※強引にカウント
        //--------------------------------------------------------------------------
         let ret_str_length : i32=args.chars().count() as i32;

        //--------------------------------------------------------------------------     
        //  数値を扱う場合、フロートも算出
        //--------------------------------------------------------------------------
         let ret_float_value  :f64 =
         if string_type_in==true  {
            0.0
         }else if  regix_jissuu.is_match(&args) == false {
            0.0
         } else {
             let _data=regix_jissuu.captures(&args).unwrap().at(0).unwrap();
             let cst_data : f64 = _data.parse().expect("変換できない文字列でした");
             cst_data
        };

④Rustにはnullがない為、入力チェックの最大値、最小値の「-1」はマジックナンバーとなります。  
nullの代替えはNone等がありますが、Noneを代入後にアクセスするとセグフォーとなるので、閾値としては使えません。  

        //--------------------------------------------------------------------------
        //  整合性チェックの初期値
        //--------------------------------------------------------------------------
        let mut ret_result: bool = true; //文字列チェック結果の初期値

        //--------------------------------------------------------------------------
        //  文字列長、値のチェック ※存在のみチェックする場合、 0,-1を指定
        //--------------------------------------------------------------------------
        if string_type_in==true   {
            if  ret_str_length <= min_in && min_in >-1  {
                message_in=format!("{}文字より多く入力して下さい", min_in);
                ret_result=false;
            } else  if   ret_str_length > max_in  && max_in > -1 {
                message_in=format!("{}文字以下で入力して下さい", max_in);
                ret_result=false;
            }
        }

        //--------------------------------------------------------------------------
        //  フロート、値のチェック ※-1はマジックナンバー
        //--------------------------------------------------------------------------
        if string_type_in==false   {
            if  ret_float_value <= min_in  as f64 && min_in !=-1  {
                message_in=format!("{}を超える値を入力して下さい", min_in);
                ret_result=false;
            } else  if   ret_float_value > max_in as f64  && max_in != -1 {
                message_in=format!("{}以下の値を入力して下さい", max_in);
                ret_result=false;
            }
        }

        //--------------------------------------------------------------------------
        //  整数、値のチェック ※-1はマジックナンバー
        //--------------------------------------------------------------------------
        if string_type_in==false   {
            if  ret_intvalue <= min_in && min_in !=-1  {
                message_in=format!("{}より多い値を入力して下さい", min_in);
                ret_result=false;
            } else  if   ret_intvalue   > max_in  && max_in != -1 {
                message_in=format!("{}以下の値を入力して下さい", max_in);
                ret_result=false;
            }
        }

⑤フォームハンドラは使用せす、ユースケース毎に生成したハッシュ配列を使用します。  
ハッシュ配列はチェックトレイトでチェックされ、戻り値に応じて能動的に処理をします。  
ここでいう処理とは、「入力エラー(ヴァリテーション)」と「サーバエラー(Fatal)」の2種類です。  
共にRust上では正常処理で返して、actix_webのHttpResponseで振り分けます。

    //--------------------------------------------------------------------------
    // ハンドラをチェック関数を使って挿入する
    //--------------------------------------------------------------------------
    input_params.insert(String::from(r"username"),  action_base::InputParametars::set_input_parametars(
        username_copy.to_string(),                           //ハンドラ文字列(ハンドラ名はハッシュの添え字で判別)
        false,                                                   //文字列で扱うなら true それ以外なら false
        r"".to_string() ,                                 //ヴァリテーションバック時のメッセージ文字列
        -1,                                                     //最小値、文字列の場合は文字列数 -1で無視 ※ディフォルト不可
        -1,                                                    //最大値、文字列の場合は文字列数 -1で無視 ※ディフォルト不可
        r"*".to_string(),                               //正規表現チェック。境界値もこれで行う。全スルーは * 
    ));
    input_params.insert(String::from(r"passwd"),  action_base::InputParametars::set_input_parametars(
        passwd_copy.to_string(),                           //ハンドラ文字列(ハンドラ名はハッシュの添え字で判別)
        false,                                                   //文字列で扱うなら true それ以外なら false
        r"".to_string() ,                                 //ヴァリテーションバック時のメッセージ文字列
        0,                                                     //最小値、文字列の場合は文字列数 -1で無視 ※ディフォルト不可
        4,                                                    //最大値、文字列の場合は文字列数 -1で無視 ※ディフォルト不可
        r"*".to_string(),                               //正規表現チェック。境界値もこれで行う。全スルーは * 
    ));

    //--------------------------------------------------------------------------
    // 入力チェック結果を集計
    //--------------------------------------------------------------------------
    for (key, value) in &input_params {
        if value.result == false {
            //詳細を追加
            valliback_detail.insert(key, &value.result_msg);
            //全体の戻り値を更新
            input_result.insert(String::from("Result"), 5);
         }
        
    }
    //--------------------------------------------------------------------------
    // ヴァリテーションがある場合は input_resultを組み立てて返却
    //--------------------------------------------------------------------------
    let check_name = String::from("Result");
    let &check_result = input_result.get(&check_name ).unwrap();
    
    // ヴァリテーションの判定
    if  check_result ==5 {
        //--------------------------------------------------------------------------
        //該当する場合は ヴァリテーションバック処理 (応答コード200)
        //--------------------------------------------------------------------------
        return Ok(HttpResponse::InternalServerError().finish()) ;//能動的なエラー返却 500
    }
